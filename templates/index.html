<!DOCTYPE html>
<html>
<head>
    <title>dsxform</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>
    <div class="main-wrapper">
        <div class="sidebar">
            <div class="logo">dsxform</div>
            <div class="tab-buttons">
                <button onclick="showTab('convert')" class="active">Convert data</button>
                <button onclick="showTab('generate')">Generate mock data</button>
            </div>
        </div>

        <div class="main-content">
            <div id="convert" class="tab active">
                <h2>Convert Data</h2>
                <p class="section-description">Transform structured data between different formats</p>
                <div class="convert-form">
                    <div class="form-group">
                        <label>Input File:</label>
                        <div class="file-input-group">
                            <input type="file" 
                                   name="file" 
                                   id="fileInput" 
                                   accept=".csv,.json,.sqlite,.xml"
                                   required>
                        </div>
                    </div>
                    <div id="tableSelection" class="form-group">
                        <label>Select Tables:</label>
                        <p id="tableSelectionMessage" style="margin: 5px 0; font-size: 0.9em; color: #666;"></p>
                        <select id="tableSelect" name="table" multiple>
                        </select>
                        <div class="table-actions">
                            <a onclick="selectAllTables()">Select All</a>
                            <a onclick="deselectAllTables()">Deselect All</a>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Convert To:</label>
                        <select name="output_format" id="outputFormat" required>
                            <option value="csv">CSV</option>
                            <option value="json">JSON</option>
                            <option value="sqlite">SQLite</option>
                            <option value="xml">XML</option>
                        </select>
                    </div>
                    <button onclick="handleConversion(event)" type="button">Convert</button>
                </div>
                <div id="conversionResult" style="display: none; margin-top: 24px;">
                    <div class="conversion-summary"></div>
                </div>
            </div>

            <div id="generate" class="tab">
                <h2>Generate Data</h2>
                <p class="section-description">Create mock data sets based on your defined patterns</p>
                
                <!-- Config selector section -->
                <div class="form-group">
                    <label>Pattern Configuration:</label>
                    <div class="configs-dropdown">
                        <select id="configSelect" name="config"></select>
                    </div>
                    <div class="config-actions">
                        <button type="button" onclick="newConfig()">New Config</button>
                        <button type="button" onclick="editConfig()">Edit Config</button>
                    </div>
                </div>
                
                <div id="generateForm">
                    <div class="form-group">
                        <label>Number of Rows:</label>
                        <input type="number" name="rows" value="100" min="1" required>
                    </div>
                    <div class="form-group">
                        <label>Output Format:</label>
                        <select name="format" required>
                            <option value="csv">CSV</option>
                            <option value="json">JSON</option>
                            <option value="sqlite">SQLite</option>
                            <option value="xml">XML</option>
                        </select>
                    </div>
                    <button type="button" onclick="handleGeneration()">Generate</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- preview modal -->
    <div id="previewModal" class="preview-modal">
        <div class="preview-content">
            <div class="preview-header">
                <h3>Preview Converted Data</h3>
                <span class="preview-close">&times;</span>
            </div>
            <pre id="previewData" class="preview-data">
                <!-- preview content will be inserted here -->
            </pre>
            <div class="preview-footer">
                <button id="finalizeConversion" type="button">Save Conversion</button>
            </div>
        </div>
    </div>

    <!-- pattern builder modal -->
    <div id="patternBuilderModal" class="pattern-builder-modal">
        <div class="pattern-builder-content">
            <div class="pattern-builder-header">
                <h3>Pattern Builder</h3>
                <span class="pattern-builder-close" onclick="closePatternBuilder()">&times;</span>
            </div>
            <div class="pattern-builder-body">
                <!-- Config Name -->
                <div class="form-group">
                    <label>Configuration Name:</label>
                    <input type="text" id="configNameInput" placeholder="Config name..." />
                </div>
                
                <!-- Headers/Fields section -->
                <div class="pattern-fields">
                    <div class="pattern-field">
                        <div class="form-group">
                            <label>Add New Field:</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" id="newFieldName" placeholder="Field name..." style="flex: 1;">
                                <button type="button" onclick="addNewField()" style="width: auto;">Add</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Pattern rows -->
                <div class="pattern-rows" id="patternRows">
                    <!-- Pattern rows will be added dynamically -->
                </div>
            </div>
            
            <div class="pattern-builder-footer">
                <button type="button" onclick="saveConfig()">Save Configuration</button>
                <button type="button" onclick="closePatternBuilder()" style="background-color: #6c757d;">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Pattern edit modal with token-based editor -->
    <div id="patternEditModal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3 class="modal-title">Edit Pattern</h3>
                <button class="modal-close" onclick="closePatternModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Pattern Components:</label>
                    <div class="pattern-builder">
                        <!-- Character classes -->
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('[a-z]')">a-z</div>
                            <span class="tooltiptext">Lowercase letters</span>
                        </div>
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('[A-Z]')">A-Z</div>
                            <span class="tooltiptext">Uppercase letters</span>
                        </div>
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('[0-9]')">0-9</div>
                            <span class="tooltiptext">Digits</span>
                        </div>
                        
                        <!-- Escape sequences -->
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('\\d')">\\d</div>
                            <span class="tooltiptext">Any digit</span>
                        </div>
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('\\w')">\\w</div>
                            <span class="tooltiptext">Any word character</span>
                        </div>
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('\\s')">\\s</div>
                            <span class="tooltiptext">Any whitespace</span>
                        </div>
                        
                        <!-- Any character -->
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('.')">.</div>
                            <span class="tooltiptext">Any character</span>
                        </div>
                        
                        <!-- Quantifiers -->
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('{3}')">Exact {n}</div>
                            <span class="tooltiptext">Exactly n times</span>
                        </div>
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('{1,5}')">Range {m,n}</div>
                            <span class="tooltiptext">Between m and n times</span>
                        </div>
                        
                        <!-- Alternation -->
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('(a|b)')">Alternation (a|b)</div>
                            <span class="tooltiptext">Match either a or b</span>
                        </div>
                        
                        <!-- Literal text -->
                        <div class="tooltip">
                            <div class="pattern-component" onclick="addToPattern('abc')">Text "abc"</div>
                            <span class="tooltiptext">Add literal text (click and edit)</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Pattern:</label>
                    <div id="tokenContainer" class="token-container">
                        <!-- Pattern tokens will be displayed here -->
                    </div>
                    <input type="hidden" id="patternInput">
                </div>
                
                <div class="pattern-preview">
                    <label>Preview:</label>
                    <div id="previewSamples" class="preview-samples">
                        <!-- Sample values will be shown here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" onclick="testPattern()">Test</button>
                <button type="button" onclick="applyPattern()">Apply</button>
                <button type="button" onclick="closePatternModal()" style="background-color: #6c757d;">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Save Config Modal -->
    <div id="saveConfigModal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3 class="modal-title">Save Configuration</h3>
                <button class="modal-close" onclick="document.getElementById('saveConfigModal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Configuration Name:</label>
                    <input type="text" id="saveConfigName" placeholder="my_config.json">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" onclick="confirmSaveConfig()">Save</button>
                <button type="button" onclick="document.getElementById('saveConfigModal').style.display='none'" style="background-color: #6c757d;">Cancel</button>
            </div>
        </div>
    </div>
    
    <footer class="footer">
        <!-- Footer content -->
    </footer>

    <script>
        function showTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        let selectedTable = null;

        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            const tableSelection = document.getElementById('tableSelection');
            tableSelection.style.display = 'none';
            selectedTable = null;
            
            if (!file) return;

            // check if file extension is supported
            const extension = file.name.toLowerCase().split('.').pop();
            const supportedFormats = ['csv', 'json', 'sqlite', 'xml'];
            
            if (!supportedFormats.includes(extension)) {
                alert('Unsupported file format. Please select a CSV, JSON, SQLite, or XML file.');
                this.value = '';
                return;
            }

            if (extension === 'sqlite') {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('output_format', 'sqlite');

                try {
                    const response = await fetch('/convert', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        const jsonData = await response.json();
                        if (jsonData.type === 'tables') {
                            const select = document.getElementById('tableSelect');
                            select.innerHTML = jsonData.tables
                                .map(t => `<option value="${t}">${t}</option>`).join('');
                            document.getElementById('tableSelectionMessage').textContent = 
                                'Hold Ctrl/Cmd to select multiple tables';
                            tableSelection.style.display = 'block';
                            
                            // select first table by default
                            if (jsonData.tables.length > 0) {
                                select.options[0].selected = true;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching tables:', error);
                }
            }
        });

        function selectAllTables() {
            const options = document.getElementById('tableSelect').options;
            for (let i = 0; i < options.length; i++) {
                options[i].selected = true;
            }
        }

        function deselectAllTables() {
            const options = document.getElementById('tableSelect').options;
            for (let i = 0; i < options.length; i++) {
                options[i].selected = false;
            }
        }

        async function handleConversion(e) {
            e.preventDefault();
            
            const fileInput = document.getElementById('fileInput');
            const outputFormat = document.getElementById('outputFormat').value;
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file');
                return;
            }

            // show loading state
            const button = e.target;
            const originalText = button.textContent;
            button.textContent = 'Generating Preview...';
            button.disabled = true;

            const formData = new FormData();
            formData.append('file', file);
            formData.append('output_format', outputFormat);

            // add any selected table for SQLite files
            const tableSelect = document.getElementById('tableSelect');
            if (tableSelect.style.display !== 'none' && tableSelect.value) {
                formData.append('table', tableSelect.value);
            }

            try {
                const response = await fetch('/preview', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(await response.text());
                }

                const result = await response.json();
                
                if (result.type === 'preview') {
                    showPreview(result);
                } else if (result.type === 'semi_data_warning') {
                    if (confirm(result.message)) {
                        formData.append('flatten', 'true');
                        const retryResponse = await fetch('/preview', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!retryResponse.ok) {
                            throw new Error(await retryResponse.text());
                        }
                        
                        const retryResult = await retryResponse.json();
                        if (retryResult.type === 'preview') {
                            showPreview(retryResult);
                        }
                    }
                }
            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        let previewData = {
            tempPath: null,
            format: null
        };

        function showPreview(result) {
            previewData.tempPath = result.temp_path;
            previewData.format = document.getElementById('outputFormat').value;
            
            const previewContainer = document.getElementById('previewData');
            previewContainer.className = `preview-data ${previewData.format}-view`;
            
            if (previewData.format === 'sqlite') {
                previewContainer.innerHTML = result.data;  // use HTML for grid view
            } else {
                previewContainer.textContent = result.data;  // use text for other formats
            }
            
            document.getElementById('previewModal').style.display = 'block';
            // reinitialize dragging each time modal is shown
            makeDraggable(document.getElementById('previewModal'));
        }

        async function getSaveFilePath(title, defaultName) {
            const response = await fetch('/save-dialog', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    title: title,
                    default_name: defaultName
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to get save path');
            }
            
            const result = await response.json();
            return result.path;
        }

        async function finalizeConversion() {
            const fileInput = document.getElementById('fileInput');
            const outputFormat = document.getElementById('outputFormat').value;
            const file = fileInput.files[0];
            
            const button = document.getElementById('finalizeConversion');
            button.disabled = true;
            button.textContent = 'Converting...';

            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('output_format', outputFormat);
                
                // add table selection if SQLite
                const tableSelect = document.getElementById('tableSelect');
                if (tableSelect.style.display !== 'none') {
                    const selectedOptions = Array.from(tableSelect.selectedOptions);
                    if (selectedOptions.length > 0) {
                        if (selectedOptions.length === 1) {
                            formData.append('table', selectedOptions[0].value);
                        } else {
                            formData.append('table', '*');
                        }
                    }
                }

                // convert and handle response
                const response = await fetch('/convert', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(await response.text());
                }

                const result = await response.json();
                if (result.type === 'success') {
                    document.getElementById('previewModal').style.display = 'none';
                    alert('Conversion completed successfully!');
                } else if (result.type === 'semi_data_warning') {
                    if (confirm(result.message)) {
                        formData.append('flatten', 'true');
                        const retryResponse = await fetch('/convert', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!retryResponse.ok) {
                            throw new Error(await retryResponse.text());
                        }

                        const retryResult = await retryResponse.json();
                        if (retryResult.type === 'success') {
                            document.getElementById('previewModal').style.display = 'none';
                            alert('Conversion completed successfully!');
                        }
                    }
                }
            } catch (error) {
                console.error('Conversion error:', error);
                alert('Error during conversion: ' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'Save Conversion';
            }
        }

        async function handleGeneration() {
            const form = document.getElementById('generateForm');
            const rows = parseInt(form.querySelector('[name="rows"]').value);
            const format = form.querySelector('[name="format"]').value;
            const configSelect = document.getElementById('configSelect');
            const selectedConfig = configSelect.value;

            if (isNaN(rows) || rows < 1) {
                alert('Invalid row count');
                return;
            }

            if (!selectedConfig) {
                alert('Please select a pattern configuration');
                return;
            }

            const button = form.querySelector('button[type="button"]');
            button.disabled = true;
            button.textContent = 'Generating...';

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rows: rows,
                        format: format,
                        config: selectedConfig
                    })
                });

                if (!response.ok) {
                    throw new Error(await response.text());
                }

                const result = await response.json();
                if (result.type === 'success') {
                    alert(result.message);
                } else if (result.type === 'cancelled') {
                    console.log('Operation cancelled');
                }
            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'Generate';
            }
        }

        // event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelector('.preview-close').onclick = () => {
                document.getElementById('previewModal').style.display = 'none';
            };

            const loadMoreBtn = document.getElementById('loadMore');
            if (loadMoreBtn) {
                loadMoreBtn.onclick = loadMoreData;
            }

            const finalizeBtn = document.getElementById('finalizeConversion');
            if (finalizeBtn) {
                finalizeBtn.addEventListener('click', finalizeConversion);
                console.log('Finalize button listener added');
            }

            makeDraggable(document.getElementById('previewModal'));
            loadConfigs();
        });

        function makeDraggable(element) {
            const header = element.querySelector('.pattern-builder-header') || 
                          element.querySelector('.preview-header');
            
            if (!header) {
                console.error('No header found for draggable element');
                return;
            }
            
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            header.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                // get mouse position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                // calculate new positions
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                let newTop = element.offsetTop - pos2;
                let newLeft = element.offsetLeft - pos1;
                
                // get viewport and element dimensions
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const elementHeight = element.offsetHeight;
                const elementWidth = element.offsetWidth;
                
                // keep element within bounds
                newTop = Math.max(0, newTop);
                newLeft = Math.max(0, newLeft);
                newTop = Math.min(viewportHeight - elementHeight, newTop);
                newLeft = Math.min(viewportWidth - elementWidth, newLeft);
                
                element.style.top = newTop + "px";
                element.style.left = newLeft + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // load available configs
        async function loadConfigs() {
            try {
                const response = await fetch('/list-configs', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load configurations');
                }
                
                const result = await response.json();
                configs = result.configs;
                
                // populate config selection
                const configSelect = document.getElementById('configSelect');
                configSelect.innerHTML = '';
                
                configs.forEach(config => {
                    const option = document.createElement('option');
                    option.value = config;
                    option.textContent = config;
                    configSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading configs:', error);
                alert('Failed to load configurations: ' + error.message);
            }
        }

        // new config creation
        function newConfig() {
            currentConfig = {
                headers: [],
                patterns: {}
            };
            
            document.getElementById('configNameInput').value = 'new_config.json';
            document.getElementById('patternRows').innerHTML = '';
            
            // show the pattern builder modal
            const patternBuilderModal = document.getElementById('patternBuilderModal');
            patternBuilderModal.style.display = 'block';
            
            setTimeout(() => {
                makeDraggable(patternBuilderModal);
            }, 0);
        }

        // edit existing config
        async function editConfig() {
            const configSelect = document.getElementById('configSelect');
            const selectedConfig = configSelect.value;
            
            if (!selectedConfig) {
                alert('Please select a configuration to edit');
                return;
            }
            
            try {
                const response = await fetch('/get-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        config: selectedConfig
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load configuration');
                }
                
                const result = await response.json();
                currentConfig = result.config;
                
                document.getElementById('configNameInput').value = selectedConfig;
                
                const patternBuilderModal = document.getElementById('patternBuilderModal');
                patternBuilderModal.style.display = 'block';
                
                // render rows and make draggable AFTER the modal is displayed
                setTimeout(() => {
                    renderPatternRows();
                    makeDraggable(patternBuilderModal);
                }, 0);
            } catch (error) {
                console.error('Error editing config:', error);
                alert('Failed to edit configuration: ' + error.message);
            }
        }

        // render pattern rows based on current config
        function renderPatternRows() {
            const rowsContainer = document.getElementById('patternRows');
            rowsContainer.innerHTML = '';
            
            if (!currentConfig || !currentConfig.headers || !currentConfig.patterns) {
                console.warn('No valid configuration to render');
                return;
            }
            
            currentConfig.headers.forEach(header => {
                const pattern = currentConfig.patterns[header] || '';
                
                const row = document.createElement('div');
                row.className = 'pattern-row';
                
                // pattern name cell
                const nameCell = document.createElement('div');
                nameCell.className = 'pattern-name';
                nameCell.textContent = header;
                row.appendChild(nameCell);
                
                // pattern value cell
                const valueCell = document.createElement('div');
                valueCell.className = 'pattern-value';
                valueCell.textContent = pattern;
                row.appendChild(valueCell);
                
                // controls cell
                const controlsCell = document.createElement('div');
                controlsCell.className = 'pattern-controls';
                
                // edit pattern
                const editButton = document.createElement('button');
                editButton.className = 'btn-icon';
                editButton.textContent = 'Edit';
                editButton.onclick = function() { editPattern(header); };
                controlsCell.appendChild(editButton);
                
                // delete pattern
                const deleteButton = document.createElement('button');
                deleteButton.className = 'btn-icon';
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = function() { deletePattern(header); };
                controlsCell.appendChild(deleteButton);
                
                row.appendChild(controlsCell);
                rowsContainer.appendChild(row);
            });
        }

        function addNewField() {
            const fieldName = document.getElementById('newFieldName').value.trim();
            
            if (!fieldName) {
                alert('Please enter a field name');
                return;
            }
            
            if (currentConfig.headers.includes(fieldName)) {
                alert('Field already exists');
                return;
            }
            
            currentConfig.headers.push(fieldName);
            currentConfig.patterns[fieldName] = '';
            
            document.getElementById('newFieldName').value = '';
            renderPatternRows();
        }

        // function for editing existing pattern
        function editPattern(field) {
            currentEditField = field;
            
            const pattern = currentConfig.patterns[field] || '';
            
            // parse the pattern into tokens and render them
            currentTokens = tokenizePattern(pattern);
            renderTokens(currentTokens);
            
            // clear previous preview samples
            document.getElementById('previewSamples').innerHTML = '';
            
            // show the pattern edit modal
            document.getElementById('patternEditModal').style.display = 'block';
            
            // test the pattern immediately
            testPattern();
        }

        function deletePattern(field) {
            if (confirm(`Are you sure you want to delete the field "${field}"?`)) {
                const index = currentConfig.headers.indexOf(field);
                if (index !== -1) {
                    currentConfig.headers.splice(index, 1);
                    delete currentConfig.patterns[field];
                    renderPatternRows();
                }
            }
        }

        // function for adding a one of the supported tokens to the pattern
        function addToPattern(component) {
            const tokens = tokenizePattern(component);
            const editableTokens = ['[a-z]', '[A-Z]', '[0-9]', '{3}', '{1,5}', '(a|b)', 'abc'];
            
            // add the token(s) to the current token list
            const startIdx = currentTokens.length;
            currentTokens = [...currentTokens, ...tokens];
            renderTokens(currentTokens);
            
            // if this is an editable token type, trigger edit mode immediately
            if (editableTokens.includes(component)) {
                setTimeout(() => {
                    // for tokens that produce only one token (most components)
                    if (tokens.length === 1) {
                        const newTokenIndex = startIdx;
                        const tokenElem = document.querySelector(`.pattern-token[data-index="${newTokenIndex}"]`);
                        if (tokenElem) {
                            tokenElem.click(); // trigger edit mode
                        }
                    }
                    // for components that might produce multiple tokens (rare)
                    else if (tokens.length > 1) {
                        // just focus the first one
                        const newTokenIndex = startIdx;
                        const tokenElem = document.querySelector(`.pattern-token[data-index="${newTokenIndex}"]`);
                        if (tokenElem) {
                            tokenElem.click(); // trigger edit mode
                        }
                    }
                }, 0);
            } else {
                // for non-editable tokens, just test the pattern
                testPattern(); // update preview after addition
            }
        }

        // remove a token by index
        function removeToken(index) {
            currentTokens.splice(index, 1);
            renderTokens(currentTokens);
            testPattern(); // update preview after removal
        }

        // drag and drop functionality for changing token order
        let draggedToken = null;
        
        function handleDragStart(e) {
            this.classList.add('dragging');
            draggedToken = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.getAttribute('data-index'));
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleDrop(e) {
            e.preventDefault();
            const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const targetIndex = parseInt(this.getAttribute('data-index'));
            
            if (sourceIndex !== targetIndex) {
                // reorder tokens
                const temp = currentTokens[sourceIndex];
                currentTokens.splice(sourceIndex, 1);
                currentTokens.splice(targetIndex, 0, temp);
                renderTokens(currentTokens);
                testPattern(); // update preview after reordering
            }
            return false;
        }
        
        function handleDragEnd() {
            document.querySelectorAll('.pattern-token').forEach(item => {
                item.classList.remove('dragging');
            });
            draggedToken = null;
        }

        // render tokens in the editor
        function renderTokens(tokens) {
            const container = document.getElementById('tokenContainer');
            container.innerHTML = '';
            
            tokens.forEach((token, index) => {
                const tokenElem = document.createElement('div');
                tokenElem.className = `pattern-token ${token.type}`;
                tokenElem.setAttribute('data-index', index);
                tokenElem.setAttribute('draggable', true);
                
                // content span
                const contentSpan = document.createElement('span');
                contentSpan.className = 'pattern-token-content';
                contentSpan.textContent = token.display;
                tokenElem.appendChild(contentSpan);
                
                // editable input
                const editInput = document.createElement('input');
                editInput.type = 'text';
                editInput.className = 'pattern-token-edit';
                editInput.value = token.display;
                tokenElem.appendChild(editInput);
                
                // delete button
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'token-delete';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation(); // prevent token click when delete is clicked
                    removeToken(index);
                };
                tokenElem.appendChild(deleteBtn);
                
                // setup click to edit
                tokenElem.addEventListener('click', function(e) {
                    if (!this.classList.contains('editing')) {
                        // enable editing
                        this.classList.add('editing');
                        const input = this.querySelector('.pattern-token-edit');
                        input.focus();
                        input.select();
                        // stop drag during edit
                        this.setAttribute('draggable', 'false');
                    }
                });
                
                // setup edit field events
                editInput.addEventListener('blur', function() {
                    saveTokenEdit(index, this.value);
                });
                
                editInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveTokenEdit(index, this.value);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelTokenEdit(index);
                    }
                });
                
                // drag events
                tokenElem.addEventListener('dragstart', handleDragStart);
                tokenElem.addEventListener('dragover', handleDragOver);
                tokenElem.addEventListener('drop', handleDrop);
                tokenElem.addEventListener('dragend', handleDragEnd);
                
                container.appendChild(tokenElem);
            });
            
            // update hidden input with pattern
            document.getElementById('patternInput').value = tokensToPattern(tokens);
        }

        // save token edit - updated to update preview after editing
        function saveTokenEdit(index, newValue) {
            const token = currentTokens[index];
            if (newValue.trim() && newValue !== token.display) {
                // try to parse the new value into appropriate token type
                try {
                    // for special token types, maintain their type but update display/value
                    if (token.type === 'character-class' || 
                        token.type === 'quantifier' || 
                        token.type === 'escape' || 
                        token.type === 'alternation') {
                        
                        const oldType = token.type;
                        
                        // validate the format based on token type
                        if (oldType === 'character-class' && !isValidCharacterClass(newValue)) {
                            throw new Error('Invalid character class format');
                        } else if (oldType === 'quantifier' && !isValidQuantifier(newValue)) {
                            throw new Error('Invalid quantifier format');
                        } else if (oldType === 'alternation' && !isValidAlternation(newValue)) {
                            throw new Error('Invalid alternation format');
                        }
                        
                        token.display = newValue;
                        token.value = newValue;
                    } else {
                        // for literals and other simple types, just update
                        token.display = newValue;
                        token.value = newValue;
                    }
                    
                    renderTokens(currentTokens);
                    testPattern(); // update preview after editing
                } catch (e) {
                    alert('Invalid token format: ' + e.message);
                    cancelTokenEdit(index);
                }
            } else {
                cancelTokenEdit(index);
            }
        }

        // cancel token edit
        function cancelTokenEdit(index) {
            renderTokens(currentTokens);
            testPattern(); // just in case the pattern was changed, update preview
        }

        // validate character class format like [a-z], [0-9], etc.
        function isValidCharacterClass(value) {
            return /^\[(\^)?[a-zA-Z0-9_\-]+\]$/.test(value);
        }

        // validate quantifier format like {3}, {1,5}
        function isValidQuantifier(value) {
            return /^\{(\d+)(?:,(\d+))?\}$/.test(value);
        }

        // validate alternation format like (a|b|c)
        function isValidAlternation(value) {
            return /^\([^()]+(?:\|[^()]+)+\)$/.test(value);
        }

        // handle drag start event with edit state check
        function handleDragStart(e) {
            if (this.classList.contains('editing')) {
                e.preventDefault();
                return false;
            }
            
            this.classList.add('dragging');
            draggedToken = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.getAttribute('data-index'));
        }

        // pattern tokenizer for visual editor - works fine so far, note: more complex alternation needs more logic
        function tokenizePattern(pattern) {
            const tokens = [];
            let i = 0;
            
            while (i < pattern.length) {
                if (pattern[i] === '\\') {
                    // escape sequences
                    const escapeChar = pattern[i+1] || '';
                    tokens.push({
                        type: 'escape',
                        value: '\\' + escapeChar,
                        display: '\\' + escapeChar
                    });
                    i += 2;
                } else if (pattern[i] === '[') {
                    // character class
                    let endIdx = pattern.indexOf(']', i);
                    if (endIdx === -1) endIdx = pattern.length;
                    const classContent = pattern.substring(i, endIdx + 1);
                    tokens.push({
                        type: 'character-class',
                        value: classContent,
                        display: classContent
                    });
                    i = endIdx + 1;
                } else if (pattern[i] === '{') {
                    // quantifier
                    let endIdx = pattern.indexOf('}', i);
                    if (endIdx === -1) endIdx = pattern.length;
                    const quantContent = pattern.substring(i, endIdx + 1);
                    tokens.push({
                        type: 'quantifier',
                        value: quantContent,
                        display: quantContent
                    });
                    i = endIdx + 1;
                } else if (pattern[i] === '(') {
                    // alternation or group, needs more work for displaying alternated tokens
                    let nestLevel = 1;
                    let endIdx = i + 1;
                    
                    while (nestLevel > 0 && endIdx < pattern.length) {
                        if (pattern[endIdx] === '(') nestLevel++;
                        if (pattern[endIdx] === ')') nestLevel--;
                        endIdx++;
                    }
                    
                    const groupContent = pattern.substring(i, endIdx);
                    tokens.push({
                        type: 'alternation',
                        value: groupContent,
                        display: groupContent
                    });
                    i = endIdx;
                } else if (pattern[i] === '.') {
                    // any character
                    tokens.push({
                        type: 'any-char',
                        value: '.',
                        display: '.'
                    });
                    i++;
                } else {
                    // literal - collect consecutive literal characters
                    let literalStart = i;
                    while (i < pattern.length && 
                           !'\\[{(.'.includes(pattern[i]) && 
                           (i === pattern.length - 1 || pattern[i+1] !== '{')) {
                        i++;
                    }
                    const literalContent = pattern.substring(literalStart, i);
                    tokens.push({
                        type: 'literal',
                        value: literalContent,
                        display: literalContent
                    });
                }
            }
            
            return tokens;
        }
        
        // convert tokens back to pattern string
        function tokensToPattern(tokens) {
            return tokens.map(token => token.value).join('');
        }

        // apply the pattern from tokens
        function applyPattern() {
            const pattern = tokensToPattern(currentTokens);
            
            if (currentEditField) {
                currentConfig.patterns[currentEditField] = pattern;
                renderPatternRows();
                closePatternModal();
            }
        }

        // preview the current pattern with samples of generated values
        async function testPattern() {
            const pattern = tokensToPattern(currentTokens);
            if (!pattern) {
                document.getElementById('previewSamples').innerHTML = 
                    '<div class="sample-item">Add some pattern components to see examples</div>';
                return;
            }
            
            try {
                const response = await fetch('/test-pattern', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        pattern: pattern,
                        samples: 5,
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to test pattern');
                }
                
                const result = await response.json();
                
                // display sample values
                const previewContainer = document.getElementById('previewSamples');
                previewContainer.innerHTML = '';
                
                result.samples.forEach(sample => {
                    const sampleElem = document.createElement('div');
                    sampleElem.className = 'sample-item';
                    sampleElem.textContent = sample;
                    previewContainer.appendChild(sampleElem);
                });
            } catch (error) {
                console.error('Error testing pattern:', error);
                document.getElementById('previewSamples').innerHTML = 
                    `<div class="sample-item error-sample">Error: ${error.message}</div>`;
            }
        }

        function closePatternModal() {
            document.getElementById('patternEditModal').style.display = 'none';
            currentEditField = '';
            currentTokens = [];
        }

        // open save config dialog
        function saveConfig() {
            // should have at least one field
            if (currentConfig.headers.length === 0) {
                alert('Configuration must have at least one field');
                return;
            }
            
            // ensure that a pattern is defined for each field
            let missingPatterns = [];
            currentConfig.headers.forEach(header => {
                if (!currentConfig.patterns[header]) {
                    missingPatterns.push(header);
                }
            });
            // tell the user which fields need patterns
            if (missingPatterns.length > 0) {
                alert(`Please define patterns for these fields: ${missingPatterns.join(', ')}`);
                return;
            }
            
            // show the save dialog with current config name
            const configNameInput = document.getElementById('configNameInput');
            document.getElementById('saveConfigName').value = configNameInput.value || 'new_config.json';
            document.getElementById('saveConfigModal').style.display = 'block';
        }

        async function confirmSaveConfig() {
            const configName = document.getElementById('saveConfigName').value.trim();
            
            if (!configName) {
                alert('Please enter a configuration name');
                return;
            }
            
            // add .json extension if not present
            let fileName = configName;
            if (!fileName.endsWith('.json')) {
                fileName += '.json';
            }
            
            try {
                const response = await fetch('/save-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        config_name: fileName,
                        config_data: currentConfig
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save configuration');
                }
                
                const result = await response.json();
                
                if (result.success) {
                    alert('Configuration saved successfully');
                    document.getElementById('saveConfigModal').style.display = 'none';
                    document.getElementById('patternBuilder').style.display = 'none';
                    
                    // reload configs list
                    loadConfigs();
                } else {
                    alert('Failed to save configuration: ' + result.message);
                }
            } catch (error) {
                console.error('Error saving config:', error);
                alert('Failed to save configuration: ' + error.message);
            }
        }

        // close pattern builder without saving
        function closePatternBuilder() {
            if (confirm('Discard all changes?')) {
                document.getElementById('patternBuilderModal').style.display = 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {

            const tooltips = document.querySelectorAll('.tooltip');
            tooltips.forEach(tooltip => {
                const tooltipText = tooltip.querySelector('.tooltiptext');
                tooltip.addEventListener('mouseover', () => {
                    tooltipText.style.visibility = 'visible';
                    tooltipText.style.opacity = '0.9';
                });
                tooltip.addEventListener('mouseout', () => {
                    tooltipText.style.visibility = 'hidden';
                    tooltipText.style.opacity = '0';
                });
            });
        });
    </script>
</body>
</html>
